/* Generated by the protocol buffer compiler.  DO NOT EDIT! */
/* Generated from: scip.proto */

#ifndef PROTOBUF_C_scip_2eproto__INCLUDED
#define PROTOBUF_C_scip_2eproto__INCLUDED

#include <protobuf-c/protobuf-c.h>

PROTOBUF_C__BEGIN_DECLS

#if PROTOBUF_C_VERSION_NUMBER < 1003000
# error This file was generated by a newer version of protoc-c which is incompatible with your libprotobuf-c headers. Please update your headers.
#elif 1004001 < PROTOBUF_C_MIN_COMPILER_VERSION
# error This file was generated by an older version of protoc-c which is incompatible with your libprotobuf-c headers. Please regenerate this file with a newer version of protoc-c.
#endif


typedef struct Scip__Index Scip__Index;
typedef struct Scip__Metadata Scip__Metadata;
typedef struct Scip__ToolInfo Scip__ToolInfo;
typedef struct Scip__Document Scip__Document;
typedef struct Scip__Symbol Scip__Symbol;
typedef struct Scip__Package Scip__Package;
typedef struct Scip__Descriptor Scip__Descriptor;
typedef struct Scip__SymbolInformation Scip__SymbolInformation;
typedef struct Scip__Relationship Scip__Relationship;
typedef struct Scip__Occurrence Scip__Occurrence;
typedef struct Scip__Diagnostic Scip__Diagnostic;


/* --- enums --- */

typedef enum _Scip__Descriptor__Suffix {
  SCIP__DESCRIPTOR__SUFFIX__UnspecifiedSuffix = 0,
  /*
   * Unit of code abstraction and/or namespacing.
   * NOTE: This corresponds to a package in Go and JVM languages.
   */
  SCIP__DESCRIPTOR__SUFFIX__Namespace = 1,
  /*
   * Use Namespace instead.
   */
  SCIP__DESCRIPTOR__SUFFIX__Package = 1,
  SCIP__DESCRIPTOR__SUFFIX__Type = 2,
  SCIP__DESCRIPTOR__SUFFIX__Term = 3,
  SCIP__DESCRIPTOR__SUFFIX__Method = 4,
  SCIP__DESCRIPTOR__SUFFIX__TypeParameter = 5,
  SCIP__DESCRIPTOR__SUFFIX__Parameter = 6,
  /*
   * Can be used for any purpose.
   */
  SCIP__DESCRIPTOR__SUFFIX__Meta = 7,
  SCIP__DESCRIPTOR__SUFFIX__Local = 8,
  SCIP__DESCRIPTOR__SUFFIX__Macro = 9
    PROTOBUF_C__FORCE_ENUM_TO_BE_INT_SIZE(SCIP__DESCRIPTOR__SUFFIX)
} Scip__Descriptor__Suffix;
/*
 * (optional) Kind represents the fine-grained category of a symbol, suitable for presenting
 * information about the symbol's meaning in the language.
 * For example:
 * - A Java method would have the kind `Method` while a Go function would
 *   have the kind `Function`, even if the symbols for these use the same
 *   syntax for the descriptor `SymbolDescriptor.Suffix.Method`.
 * - A Go struct has the symbol kind `Struct` while a Java class has
 *   the symbol kind `Class` even if they both have the same descriptor:
 *   `SymbolDescriptor.Suffix.Type`.
 * Since Kind is more fine-grained than Suffix:
 * - If two symbols have the same Kind, they should share the same Suffix.
 * - If two symbols have different Suffixes, they should have different Kinds.
 */
typedef enum _Scip__SymbolInformation__Kind {
  SCIP__SYMBOL_INFORMATION__KIND__UnspecifiedKind = 0,
  /*
   * A method which may or may not have a body. For Java, Kotlin etc.
   */
  SCIP__SYMBOL_INFORMATION__KIND__AbstractMethod = 66,
  /*
   * For Ruby's attr_accessor
   */
  SCIP__SYMBOL_INFORMATION__KIND__Accessor = 72,
  SCIP__SYMBOL_INFORMATION__KIND__Array = 1,
  /*
   * For Alloy
   */
  SCIP__SYMBOL_INFORMATION__KIND__Assertion = 2,
  SCIP__SYMBOL_INFORMATION__KIND__AssociatedType = 3,
  /*
   * For C++
   */
  SCIP__SYMBOL_INFORMATION__KIND__Attribute = 4,
  /*
   * For Lean
   */
  SCIP__SYMBOL_INFORMATION__KIND__Axiom = 5,
  SCIP__SYMBOL_INFORMATION__KIND__Boolean = 6,
  SCIP__SYMBOL_INFORMATION__KIND__Class = 7,
  /*
   * For C++
   */
  SCIP__SYMBOL_INFORMATION__KIND__Concept = 86,
  SCIP__SYMBOL_INFORMATION__KIND__Constant = 8,
  SCIP__SYMBOL_INFORMATION__KIND__Constructor = 9,
  /*
   * For Solidity
   */
  SCIP__SYMBOL_INFORMATION__KIND__Contract = 62,
  /*
   * For Haskell
   */
  SCIP__SYMBOL_INFORMATION__KIND__DataFamily = 10,
  /*
   * For C# and F#
   */
  SCIP__SYMBOL_INFORMATION__KIND__Delegate = 73,
  SCIP__SYMBOL_INFORMATION__KIND__Enum = 11,
  SCIP__SYMBOL_INFORMATION__KIND__EnumMember = 12,
  SCIP__SYMBOL_INFORMATION__KIND__Error = 63,
  SCIP__SYMBOL_INFORMATION__KIND__Event = 13,
  /*
   * For Dart
   */
  SCIP__SYMBOL_INFORMATION__KIND__Extension = 84,
  /*
   * For Alloy
   */
  SCIP__SYMBOL_INFORMATION__KIND__Fact = 14,
  SCIP__SYMBOL_INFORMATION__KIND__Field = 15,
  SCIP__SYMBOL_INFORMATION__KIND__File = 16,
  SCIP__SYMBOL_INFORMATION__KIND__Function = 17,
  /*
   * For 'get' in Swift, 'attr_reader' in Ruby
   */
  SCIP__SYMBOL_INFORMATION__KIND__Getter = 18,
  /*
   * For Raku
   */
  SCIP__SYMBOL_INFORMATION__KIND__Grammar = 19,
  /*
   * For Purescript and Lean
   */
  SCIP__SYMBOL_INFORMATION__KIND__Instance = 20,
  SCIP__SYMBOL_INFORMATION__KIND__Interface = 21,
  SCIP__SYMBOL_INFORMATION__KIND__Key = 22,
  /*
   * For Racket
   */
  SCIP__SYMBOL_INFORMATION__KIND__Lang = 23,
  /*
   * For Lean
   */
  SCIP__SYMBOL_INFORMATION__KIND__Lemma = 24,
  /*
   * For solidity
   */
  SCIP__SYMBOL_INFORMATION__KIND__Library = 64,
  SCIP__SYMBOL_INFORMATION__KIND__Macro = 25,
  SCIP__SYMBOL_INFORMATION__KIND__Method = 26,
  /*
   * For Ruby
   */
  SCIP__SYMBOL_INFORMATION__KIND__MethodAlias = 74,
  /*
   * Analogous to 'ThisParameter' and 'SelfParameter', but for languages
   * like Go where the receiver doesn't have a conventional name.
   */
  SCIP__SYMBOL_INFORMATION__KIND__MethodReceiver = 27,
  /*
   * Analogous to 'AbstractMethod', for Go.
   */
  SCIP__SYMBOL_INFORMATION__KIND__MethodSpecification = 67,
  /*
   * For Protobuf
   */
  SCIP__SYMBOL_INFORMATION__KIND__Message = 28,
  /*
   * For Dart
   */
  SCIP__SYMBOL_INFORMATION__KIND__Mixin = 85,
  /*
   * For Solidity
   */
  SCIP__SYMBOL_INFORMATION__KIND__Modifier = 65,
  SCIP__SYMBOL_INFORMATION__KIND__Module = 29,
  SCIP__SYMBOL_INFORMATION__KIND__Namespace = 30,
  SCIP__SYMBOL_INFORMATION__KIND__Null = 31,
  SCIP__SYMBOL_INFORMATION__KIND__Number = 32,
  SCIP__SYMBOL_INFORMATION__KIND__Object = 33,
  SCIP__SYMBOL_INFORMATION__KIND__Operator = 34,
  SCIP__SYMBOL_INFORMATION__KIND__Package = 35,
  SCIP__SYMBOL_INFORMATION__KIND__PackageObject = 36,
  SCIP__SYMBOL_INFORMATION__KIND__Parameter = 37,
  SCIP__SYMBOL_INFORMATION__KIND__ParameterLabel = 38,
  /*
   * For Haskell's PatternSynonyms
   */
  SCIP__SYMBOL_INFORMATION__KIND__Pattern = 39,
  /*
   * For Alloy
   */
  SCIP__SYMBOL_INFORMATION__KIND__Predicate = 40,
  SCIP__SYMBOL_INFORMATION__KIND__Property = 41,
  /*
   * Analogous to 'Trait' and 'TypeClass', for Swift and Objective-C
   */
  SCIP__SYMBOL_INFORMATION__KIND__Protocol = 42,
  /*
   * Analogous to 'AbstractMethod', for Swift and Objective-C.
   */
  SCIP__SYMBOL_INFORMATION__KIND__ProtocolMethod = 68,
  /*
   * Analogous to 'AbstractMethod', for C++.
   */
  SCIP__SYMBOL_INFORMATION__KIND__PureVirtualMethod = 69,
  /*
   * For Haskell
   */
  SCIP__SYMBOL_INFORMATION__KIND__Quasiquoter = 43,
  /*
   * 'self' in Python, Rust, Swift etc.
   */
  SCIP__SYMBOL_INFORMATION__KIND__SelfParameter = 44,
  /*
   * For 'set' in Swift, 'attr_writer' in Ruby
   */
  SCIP__SYMBOL_INFORMATION__KIND__Setter = 45,
  /*
   * For Alloy, analogous to 'Struct'.
   */
  SCIP__SYMBOL_INFORMATION__KIND__Signature = 46,
  /*
   * For Ruby
   */
  SCIP__SYMBOL_INFORMATION__KIND__SingletonClass = 75,
  /*
   * Analogous to 'StaticMethod', for Ruby.
   */
  SCIP__SYMBOL_INFORMATION__KIND__SingletonMethod = 76,
  /*
   * Analogous to 'StaticField', for C++
   */
  SCIP__SYMBOL_INFORMATION__KIND__StaticDataMember = 77,
  /*
   * For C#
   */
  SCIP__SYMBOL_INFORMATION__KIND__StaticEvent = 78,
  /*
   * For C#
   */
  SCIP__SYMBOL_INFORMATION__KIND__StaticField = 79,
  /*
   * For Java, C#, C++ etc.
   */
  SCIP__SYMBOL_INFORMATION__KIND__StaticMethod = 80,
  /*
   * For C#, TypeScript etc.
   */
  SCIP__SYMBOL_INFORMATION__KIND__StaticProperty = 81,
  /*
   * For C, C++
   */
  SCIP__SYMBOL_INFORMATION__KIND__StaticVariable = 82,
  SCIP__SYMBOL_INFORMATION__KIND__String = 48,
  SCIP__SYMBOL_INFORMATION__KIND__Struct = 49,
  /*
   * For Swift
   */
  SCIP__SYMBOL_INFORMATION__KIND__Subscript = 47,
  /*
   * For Lean
   */
  SCIP__SYMBOL_INFORMATION__KIND__Tactic = 50,
  /*
   * For Lean
   */
  SCIP__SYMBOL_INFORMATION__KIND__Theorem = 51,
  /*
   * Method receiver for languages
   * 'this' in JavaScript, C++, Java etc.
   */
  SCIP__SYMBOL_INFORMATION__KIND__ThisParameter = 52,
  /*
   * Analogous to 'Protocol' and 'TypeClass', for Rust, Scala etc.
   */
  SCIP__SYMBOL_INFORMATION__KIND__Trait = 53,
  /*
   * Analogous to 'AbstractMethod', for Rust, Scala etc.
   */
  SCIP__SYMBOL_INFORMATION__KIND__TraitMethod = 70,
  /*
   * Data type definition for languages like OCaml which use `type`
   * rather than separate keywords like `struct` and `enum`.
   */
  SCIP__SYMBOL_INFORMATION__KIND__Type = 54,
  SCIP__SYMBOL_INFORMATION__KIND__TypeAlias = 55,
  /*
   * Analogous to 'Trait' and 'Protocol', for Haskell, Purescript etc.
   */
  SCIP__SYMBOL_INFORMATION__KIND__TypeClass = 56,
  /*
   * Analogous to 'AbstractMethod', for Haskell, Purescript etc.
   */
  SCIP__SYMBOL_INFORMATION__KIND__TypeClassMethod = 71,
  /*
   * For Haskell
   */
  SCIP__SYMBOL_INFORMATION__KIND__TypeFamily = 57,
  SCIP__SYMBOL_INFORMATION__KIND__TypeParameter = 58,
  /*
   * For C, C++, Capn Proto
   */
  SCIP__SYMBOL_INFORMATION__KIND__Union = 59,
  SCIP__SYMBOL_INFORMATION__KIND__Value = 60,
  /*
   * Next = 87;
   * Feel free to open a PR proposing new language-specific kinds.
   */
  SCIP__SYMBOL_INFORMATION__KIND__Variable = 61
    PROTOBUF_C__FORCE_ENUM_TO_BE_INT_SIZE(SCIP__SYMBOL_INFORMATION__KIND)
} Scip__SymbolInformation__Kind;
typedef enum _Scip__ProtocolVersion {
  SCIP__PROTOCOL_VERSION__UnspecifiedProtocolVersion = 0
    PROTOBUF_C__FORCE_ENUM_TO_BE_INT_SIZE(SCIP__PROTOCOL_VERSION)
} Scip__ProtocolVersion;
typedef enum _Scip__TextEncoding {
  SCIP__TEXT_ENCODING__UnspecifiedTextEncoding = 0,
  SCIP__TEXT_ENCODING__UTF8 = 1,
  SCIP__TEXT_ENCODING__UTF16 = 2
    PROTOBUF_C__FORCE_ENUM_TO_BE_INT_SIZE(SCIP__TEXT_ENCODING)
} Scip__TextEncoding;
/*
 * Encoding used to interpret the 'character' value in source ranges.
 */
typedef enum _Scip__PositionEncoding {
  /*
   * Default value. This value should not be used by new SCIP indexers
   * so that a consumer can process the SCIP index without ambiguity.
   */
  SCIP__POSITION_ENCODING__UnspecifiedPositionEncoding = 0,
  /*
   * The 'character' value is interpreted as an offset in terms
   * of UTF-8 code units (i.e. bytes).
   * Example: For the string "🚀 Woo" in UTF-8, the bytes are
   * [240, 159, 154, 128, 32, 87, 111, 111], so the offset for 'W'
   * would be 5.
   */
  SCIP__POSITION_ENCODING__UTF8CodeUnitOffsetFromLineStart = 1,
  /*
   * The 'character' value is interpreted as an offset in terms
   * of UTF-16 code units (each is 2 bytes).
   * Example: For the string "🚀 Woo", the UTF-16 code units are
   * ['\ud83d', '\ude80', ' ', 'W', 'o', 'o'], so the offset for 'W'
   * would be 3.
   */
  SCIP__POSITION_ENCODING__UTF16CodeUnitOffsetFromLineStart = 2,
  /*
   * The 'character' value is interpreted as an offset in terms
   * of UTF-32 code units (each is 4 bytes).
   * Example: For the string "🚀 Woo", the UTF-32 code units are
   * ['🚀', ' ', 'W', 'o', 'o'], so the offset for 'W' would be 2.
   */
  SCIP__POSITION_ENCODING__UTF32CodeUnitOffsetFromLineStart = 3
    PROTOBUF_C__FORCE_ENUM_TO_BE_INT_SIZE(SCIP__POSITION_ENCODING)
} Scip__PositionEncoding;
/*
 * SymbolRole declares what "role" a symbol has in an occurrence. A role is
 * encoded as a bitset where each bit represents a different role. For example,
 * to determine if the `Import` role is set, test whether the second bit of the
 * enum value is defined. In pseudocode, this can be implemented with the
 * logic: `const isImportRole = (role.value & SymbolRole.Import.value) > 0`.
 */
typedef enum _Scip__SymbolRole {
  /*
   * This case is not meant to be used; it only exists to avoid an error
   * from the Protobuf code generator.
   */
  SCIP__SYMBOL_ROLE__UnspecifiedSymbolRole = 0,
  /*
   * Is the symbol defined here? If not, then this is a symbol reference.
   */
  SCIP__SYMBOL_ROLE__Definition = 1,
  /*
   * Is the symbol imported here?
   */
  SCIP__SYMBOL_ROLE__Import = 2,
  /*
   * Is the symbol written here?
   */
  SCIP__SYMBOL_ROLE__WriteAccess = 4,
  /*
   * Is the symbol read here?
   */
  SCIP__SYMBOL_ROLE__ReadAccess = 8,
  /*
   * Is the symbol in generated code?
   */
  SCIP__SYMBOL_ROLE__Generated = 16,
  /*
   * Is the symbol in test code?
   */
  SCIP__SYMBOL_ROLE__Test = 32,
  /*
   * Is this a signature for a symbol that is defined elsewhere?
   * Applies to forward declarations for languages like C, C++
   * and Objective-C, as well as `val` declarations in interface
   * files in languages like SML and OCaml.
   */
  SCIP__SYMBOL_ROLE__ForwardDefinition = 64
    PROTOBUF_C__FORCE_ENUM_TO_BE_INT_SIZE(SCIP__SYMBOL_ROLE)
} Scip__SymbolRole;
typedef enum _Scip__SyntaxKind {
  SCIP__SYNTAX_KIND__UnspecifiedSyntaxKind = 0,
  /*
   * Comment, including comment markers and text
   */
  SCIP__SYNTAX_KIND__Comment = 1,
  /*
   * `;` `.` `,`
   */
  SCIP__SYNTAX_KIND__PunctuationDelimiter = 2,
  /*
   * (), {}, [] when used syntactically
   */
  SCIP__SYNTAX_KIND__PunctuationBracket = 3,
  /*
   * `if`, `else`, `return`, `class`, etc.
   */
  SCIP__SYNTAX_KIND__Keyword = 4,
  SCIP__SYNTAX_KIND__IdentifierKeyword = 4,
  /*
   * `+`, `*`, etc.
   */
  SCIP__SYNTAX_KIND__IdentifierOperator = 5,
  /*
   * non-specific catch-all for any identifier not better described elsewhere
   */
  SCIP__SYNTAX_KIND__Identifier = 6,
  /*
   * Identifiers builtin to the language: `min`, `print` in Python.
   */
  SCIP__SYNTAX_KIND__IdentifierBuiltin = 7,
  /*
   * Identifiers representing `null`-like values: `None` in Python, `nil` in Go.
   */
  SCIP__SYNTAX_KIND__IdentifierNull = 8,
  /*
   * `xyz` in `const xyz = "hello"`
   */
  SCIP__SYNTAX_KIND__IdentifierConstant = 9,
  /*
   * `var X = "hello"` in Go
   */
  SCIP__SYNTAX_KIND__IdentifierMutableGlobal = 10,
  /*
   * Parameter definition and references
   */
  SCIP__SYNTAX_KIND__IdentifierParameter = 11,
  /*
   * Identifiers for variable definitions and references within a local scope
   */
  SCIP__SYNTAX_KIND__IdentifierLocal = 12,
  /*
   * Identifiers that shadow other identifiers in an outer scope
   */
  SCIP__SYNTAX_KIND__IdentifierShadowed = 13,
  /*
   * Identifier representing a unit of code abstraction and/or namespacing.
   * NOTE: This corresponds to a package in Go and JVM languages,
   * and a module in languages like Python and JavaScript.
   */
  SCIP__SYNTAX_KIND__IdentifierNamespace = 14,
  SCIP__SYNTAX_KIND__IdentifierModule = 14,
  /*
   * Function references, including calls
   */
  SCIP__SYNTAX_KIND__IdentifierFunction = 15,
  /*
   * Function definition only
   */
  SCIP__SYNTAX_KIND__IdentifierFunctionDefinition = 16,
  /*
   * Macro references, including invocations
   */
  SCIP__SYNTAX_KIND__IdentifierMacro = 17,
  /*
   * Macro definition only
   */
  SCIP__SYNTAX_KIND__IdentifierMacroDefinition = 18,
  /*
   * non-builtin types
   */
  SCIP__SYNTAX_KIND__IdentifierType = 19,
  /*
   * builtin types only, such as `str` for Python or `int` in Go
   */
  SCIP__SYNTAX_KIND__IdentifierBuiltinType = 20,
  /*
   * Python decorators, c-like __attribute__
   */
  SCIP__SYNTAX_KIND__IdentifierAttribute = 21,
  /*
   * `\b`
   */
  SCIP__SYNTAX_KIND__RegexEscape = 22,
  /*
   * `*`, `+`
   */
  SCIP__SYNTAX_KIND__RegexRepeated = 23,
  /*
   * `.`
   */
  SCIP__SYNTAX_KIND__RegexWildcard = 24,
  /*
   * `(`, `)`, `[`, `]`
   */
  SCIP__SYNTAX_KIND__RegexDelimiter = 25,
  /*
   * `|`, `-`
   */
  SCIP__SYNTAX_KIND__RegexJoin = 26,
  /*
   * Literal strings: "Hello, world!"
   */
  SCIP__SYNTAX_KIND__StringLiteral = 27,
  /*
   * non-regex escapes: "\t", "\n"
   */
  SCIP__SYNTAX_KIND__StringLiteralEscape = 28,
  /*
   * datetimes within strings, special words within a string, `{}` in format strings
   */
  SCIP__SYNTAX_KIND__StringLiteralSpecial = 29,
  /*
   * "key" in { "key": "value" }, useful for example in JSON
   */
  SCIP__SYNTAX_KIND__StringLiteralKey = 30,
  /*
   * 'c' or similar, in languages that differentiate strings and characters
   */
  SCIP__SYNTAX_KIND__CharacterLiteral = 31,
  /*
   * Literal numbers, both floats and integers
   */
  SCIP__SYNTAX_KIND__NumericLiteral = 32,
  /*
   * `true`, `false`
   */
  SCIP__SYNTAX_KIND__BooleanLiteral = 33,
  /*
   * Used for XML-like tags
   */
  SCIP__SYNTAX_KIND__Tag = 34,
  /*
   * Attribute name in XML-like tags
   */
  SCIP__SYNTAX_KIND__TagAttribute = 35,
  /*
   * Delimiters for XML-like tags
   */
  SCIP__SYNTAX_KIND__TagDelimiter = 36
    PROTOBUF_C__FORCE_ENUM_TO_BE_INT_SIZE(SCIP__SYNTAX_KIND)
} Scip__SyntaxKind;
typedef enum _Scip__Severity {
  SCIP__SEVERITY__UnspecifiedSeverity = 0,
  SCIP__SEVERITY__Error = 1,
  SCIP__SEVERITY__Warning = 2,
  SCIP__SEVERITY__Information = 3,
  SCIP__SEVERITY__Hint = 4
    PROTOBUF_C__FORCE_ENUM_TO_BE_INT_SIZE(SCIP__SEVERITY)
} Scip__Severity;
typedef enum _Scip__DiagnosticTag {
  SCIP__DIAGNOSTIC_TAG__UnspecifiedDiagnosticTag = 0,
  SCIP__DIAGNOSTIC_TAG__Unnecessary = 1,
  SCIP__DIAGNOSTIC_TAG__Deprecated = 2
    PROTOBUF_C__FORCE_ENUM_TO_BE_INT_SIZE(SCIP__DIAGNOSTIC_TAG)
} Scip__DiagnosticTag;
/*
 * Language standardises names of common programming languages that can be used
 * for the `Document.language` field. The primary purpose of this enum is to
 * prevent a situation where we have a single programming language ends up with
 * multiple string representations. For example, the C++ language uses the name
 * "CPP" in this enum and other names such as "cpp" are incompatible.
 * Feel free to send a pull-request to add missing programming languages.
 */
typedef enum _Scip__Language {
  SCIP__LANGUAGE__UnspecifiedLanguage = 0,
  SCIP__LANGUAGE__ABAP = 60,
  SCIP__LANGUAGE__Apex = 96,
  SCIP__LANGUAGE__APL = 49,
  SCIP__LANGUAGE__Ada = 39,
  SCIP__LANGUAGE__Agda = 45,
  SCIP__LANGUAGE__AsciiDoc = 86,
  SCIP__LANGUAGE__Assembly = 58,
  SCIP__LANGUAGE__Awk = 66,
  SCIP__LANGUAGE__Bat = 68,
  SCIP__LANGUAGE__BibTeX = 81,
  SCIP__LANGUAGE__C = 34,
  SCIP__LANGUAGE__COBOL = 59,
  /*
   * C++ (the name "CPP" was chosen for consistency with LSP)
   */
  SCIP__LANGUAGE__CPP = 35,
  SCIP__LANGUAGE__CSS = 26,
  SCIP__LANGUAGE__CSharp = 1,
  SCIP__LANGUAGE__Clojure = 8,
  SCIP__LANGUAGE__Coffeescript = 21,
  SCIP__LANGUAGE__CommonLisp = 9,
  SCIP__LANGUAGE__Coq = 47,
  SCIP__LANGUAGE__CUDA = 97,
  SCIP__LANGUAGE__Dart = 3,
  SCIP__LANGUAGE__Delphi = 57,
  SCIP__LANGUAGE__Diff = 88,
  SCIP__LANGUAGE__Dockerfile = 80,
  SCIP__LANGUAGE__Dyalog = 50,
  SCIP__LANGUAGE__Elixir = 17,
  SCIP__LANGUAGE__Erlang = 18,
  SCIP__LANGUAGE__FSharp = 42,
  SCIP__LANGUAGE__Fish = 65,
  SCIP__LANGUAGE__Flow = 24,
  SCIP__LANGUAGE__Fortran = 56,
  SCIP__LANGUAGE__Git_Commit = 91,
  SCIP__LANGUAGE__Git_Config = 89,
  SCIP__LANGUAGE__Git_Rebase = 92,
  SCIP__LANGUAGE__Go = 33,
  SCIP__LANGUAGE__GraphQL = 98,
  SCIP__LANGUAGE__Groovy = 7,
  SCIP__LANGUAGE__HTML = 30,
  SCIP__LANGUAGE__Hack = 20,
  SCIP__LANGUAGE__Handlebars = 90,
  SCIP__LANGUAGE__Haskell = 44,
  SCIP__LANGUAGE__Idris = 46,
  SCIP__LANGUAGE__Ini = 72,
  SCIP__LANGUAGE__J = 51,
  SCIP__LANGUAGE__JSON = 75,
  SCIP__LANGUAGE__Java = 6,
  SCIP__LANGUAGE__JavaScript = 22,
  SCIP__LANGUAGE__JavaScriptReact = 93,
  SCIP__LANGUAGE__Jsonnet = 76,
  SCIP__LANGUAGE__Julia = 55,
  SCIP__LANGUAGE__Justfile = 109,
  SCIP__LANGUAGE__Kotlin = 4,
  SCIP__LANGUAGE__LaTeX = 83,
  SCIP__LANGUAGE__Lean = 48,
  SCIP__LANGUAGE__Less = 27,
  SCIP__LANGUAGE__Lua = 12,
  SCIP__LANGUAGE__Luau = 108,
  SCIP__LANGUAGE__Makefile = 79,
  SCIP__LANGUAGE__Markdown = 84,
  SCIP__LANGUAGE__Matlab = 52,
  /*
   * https://nickel-lang.org/
   */
  SCIP__LANGUAGE__Nickel = 110,
  SCIP__LANGUAGE__Nix = 77,
  SCIP__LANGUAGE__OCaml = 41,
  SCIP__LANGUAGE__Objective_C = 36,
  SCIP__LANGUAGE__Objective_CPP = 37,
  SCIP__LANGUAGE__Pascal = 99,
  SCIP__LANGUAGE__PHP = 19,
  SCIP__LANGUAGE__PLSQL = 70,
  SCIP__LANGUAGE__Perl = 13,
  SCIP__LANGUAGE__PowerShell = 67,
  SCIP__LANGUAGE__Prolog = 71,
  SCIP__LANGUAGE__Protobuf = 100,
  SCIP__LANGUAGE__Python = 15,
  SCIP__LANGUAGE__R = 54,
  SCIP__LANGUAGE__Racket = 11,
  SCIP__LANGUAGE__Raku = 14,
  SCIP__LANGUAGE__Razor = 62,
  /*
   * Internal language for testing SCIP
   */
  SCIP__LANGUAGE__Repro = 102,
  SCIP__LANGUAGE__ReST = 85,
  SCIP__LANGUAGE__Ruby = 16,
  SCIP__LANGUAGE__Rust = 40,
  SCIP__LANGUAGE__SAS = 61,
  SCIP__LANGUAGE__SCSS = 29,
  SCIP__LANGUAGE__SML = 43,
  SCIP__LANGUAGE__SQL = 69,
  SCIP__LANGUAGE__Sass = 28,
  SCIP__LANGUAGE__Scala = 5,
  SCIP__LANGUAGE__Scheme = 10,
  /*
   * Bash
   */
  SCIP__LANGUAGE__ShellScript = 64,
  SCIP__LANGUAGE__Skylark = 78,
  SCIP__LANGUAGE__Slang = 107,
  SCIP__LANGUAGE__Solidity = 95,
  SCIP__LANGUAGE__Svelte = 106,
  SCIP__LANGUAGE__Swift = 2,
  SCIP__LANGUAGE__Tcl = 101,
  SCIP__LANGUAGE__TOML = 73,
  SCIP__LANGUAGE__TeX = 82,
  SCIP__LANGUAGE__Thrift = 103,
  SCIP__LANGUAGE__TypeScript = 23,
  SCIP__LANGUAGE__TypeScriptReact = 94,
  SCIP__LANGUAGE__Verilog = 104,
  SCIP__LANGUAGE__VHDL = 105,
  SCIP__LANGUAGE__VisualBasic = 63,
  SCIP__LANGUAGE__Vue = 25,
  SCIP__LANGUAGE__Wolfram = 53,
  SCIP__LANGUAGE__XML = 31,
  SCIP__LANGUAGE__XSL = 32,
  SCIP__LANGUAGE__YAML = 74,
  /*
   * NextLanguage = 111;
   * Steps add a new language:
   * 1. Copy-paste the "NextLanguage = N" line above
   * 2. Increment "NextLanguage = N" to "NextLanguage = N+1"
   * 3. Replace "NextLanguage = N" with the name of the new language.
   * 4. Move the new language to the correct line above using alphabetical order
   * 5. (optional) Add a brief comment behind the language if the name is not self-explanatory
   */
  SCIP__LANGUAGE__Zig = 38
    PROTOBUF_C__FORCE_ENUM_TO_BE_INT_SIZE(SCIP__LANGUAGE)
} Scip__Language;

/* --- messages --- */

/*
 * Index represents a complete SCIP index for a workspace this is rooted at a
 * single directory. An Index message payload can have a large memory footprint
 * and it's therefore recommended to emit and consume an Index payload one field
 * value at a time. To permit streaming consumption of an Index payload, the
 * `metadata` field must appear at the start of the stream and must only appear
 * once in the stream. Other field values may appear in any order.
 */
struct  Scip__Index
{
  ProtobufCMessage base;
  /*
   * Metadata about this index.
   */
  Scip__Metadata *metadata;
  /*
   * Documents that belong to this index.
   */
  size_t n_documents;
  Scip__Document **documents;
  /*
   * (optional) Symbols that are referenced from this index but are defined in
   * an external package (a separate `Index` message). Leave this field empty
   * if you assume the external package will get indexed separately. If the
   * external package won't get indexed for some reason then you can use this
   * field to provide hover documentation for those external symbols.
   */
  /*
   * IMPORTANT: When adding a new field to `Index` here, add a matching
   * function in `IndexVisitor` and update `ParseStreaming`.
   */
  size_t n_external_symbols;
  Scip__SymbolInformation **external_symbols;
};
#define SCIP__INDEX__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&scip__index__descriptor) \
    , NULL, 0,NULL, 0,NULL }


struct  Scip__Metadata
{
  ProtobufCMessage base;
  /*
   * Which version of this protocol was used to generate this index?
   */
  Scip__ProtocolVersion version;
  /*
   * Information about the tool that produced this index.
   */
  Scip__ToolInfo *tool_info;
  /*
   * URI-encoded absolute path to the root directory of this index. All
   * documents in this index must appear in a subdirectory of this root
   * directory.
   */
  char *project_root;
  /*
   * Text encoding of the source files on disk that are referenced from
   * `Document.relative_path`. This value is unrelated to the `Document.text`
   * field, which is a Protobuf string and hence must be UTF-8 encoded.
   */
  Scip__TextEncoding text_document_encoding;
};
#define SCIP__METADATA__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&scip__metadata__descriptor) \
    , SCIP__PROTOCOL_VERSION__UnspecifiedProtocolVersion, NULL, (char *)protobuf_c_empty_string, SCIP__TEXT_ENCODING__UnspecifiedTextEncoding }


struct  Scip__ToolInfo
{
  ProtobufCMessage base;
  /*
   * Name of the indexer that produced this index.
   */
  char *name;
  /*
   * Version of the indexer that produced this index.
   */
  char *version;
  /*
   * Command-line arguments that were used to invoke this indexer.
   */
  size_t n_arguments;
  char **arguments;
};
#define SCIP__TOOL_INFO__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&scip__tool_info__descriptor) \
    , (char *)protobuf_c_empty_string, (char *)protobuf_c_empty_string, 0,NULL }


/*
 * Document defines the metadata about a source file on disk.
 */
struct  Scip__Document
{
  ProtobufCMessage base;
  /*
   * The string ID for the programming language this file is written in.
   * The `Language` enum contains the names of most common programming languages.
   * This field is typed as a string to permit any programming language, including
   * ones that are not specified by the `Language` enum.
   */
  char *language;
  /*
   * (Required) Unique path to the text document.
   * 1. The path must be relative to the directory supplied in the associated
   *    `Metadata.project_root`.
   * 2. The path must not begin with a leading '/'.
   * 3. The path must point to a regular file, not a symbolic link.
   * 4. The path must use '/' as the separator, including on Windows.
   * 5. The path must be canonical; it cannot include empty components ('//'),
   *    or '.' or '..'.
   */
  char *relative_path;
  /*
   * Occurrences that appear in this file.
   */
  size_t n_occurrences;
  Scip__Occurrence **occurrences;
  /*
   * Symbols that are "defined" within this document.
   * This should include symbols which technically do not have any definition,
   * but have a reference and are defined by some other symbol (see
   * Relationship.is_definition).
   */
  size_t n_symbols;
  Scip__SymbolInformation **symbols;
  /*
   * (optional) Text contents of the this document. Indexers are not expected to
   * include the text by default. It's preferrable that clients read the text
   * contents from the file system by resolving the absolute path from joining
   * `Index.metadata.project_root` and `Document.relative_path`. This field was
   * introduced to support `SymbolInformation.signature_documentation`, but it
   * can be used for other purposes as well, for example testing or when working
   * with virtual/in-memory documents.
   */
  char *text;
  /*
   * Specifies the encoding used for source ranges in this Document.
   * Usually, this will match the type used to index the string type
   * in the indexer's implementation language in O(1) time.
   * - For an indexer implemented in JVM/.NET language or JavaScript/TypeScript,
   *   use UTF16CodeUnitOffsetFromLineStart.
   * - For an indexer implemented in Python,
   *   use UTF32CodeUnitOffsetFromLineStart.
   * - For an indexer implemented in Go, Rust or C++,
   *   use UTF8ByteOffsetFromLineStart.
   */
  Scip__PositionEncoding position_encoding;
};
#define SCIP__DOCUMENT__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&scip__document__descriptor) \
    , (char *)protobuf_c_empty_string, (char *)protobuf_c_empty_string, 0,NULL, 0,NULL, (char *)protobuf_c_empty_string, SCIP__POSITION_ENCODING__UnspecifiedPositionEncoding }


/*
 * Symbol is similar to a URI, it identifies a class, method, or a local
 * variable. `SymbolInformation` contains rich metadata about symbols such as
 * the docstring.
 * Symbol has a standardized string representation, which can be used
 * interchangeably with `Symbol`. The syntax for Symbol is the following:
 * ```
 * # (<x>)+ stands for one or more repetitions of <x>
 * # (<x>)? stands for zero or one occurrence of <x>
 * <symbol>               ::= <scheme> ' ' <package> ' ' (<descriptor>)+ | 'local ' <local-id>
 * <package>              ::= <manager> ' ' <package-name> ' ' <version>
 * <scheme>               ::= any UTF-8, escape spaces with double space. Must not be empty nor start with 'local'
 * <manager>              ::= any UTF-8, escape spaces with double space. Use the placeholder '.' to indicate an empty value
 * <package-name>         ::= same as above
 * <version>              ::= same as above
 * <descriptor>           ::= <namespace> | <type> | <term> | <method> | <type-parameter> | <parameter> | <meta> | <macro>
 * <namespace>            ::= <name> '/'
 * <type>                 ::= <name> '#'
 * <term>                 ::= <name> '.'
 * <meta>                 ::= <name> ':'
 * <macro>                ::= <name> '!'
 * <method>               ::= <name> '(' (<method-disambiguator>)? ').'
 * <type-parameter>       ::= '[' <name> ']'
 * <parameter>            ::= '(' <name> ')'
 * <name>                 ::= <identifier>
 * <method-disambiguator> ::= <simple-identifier>
 * <identifier>           ::= <simple-identifier> | <escaped-identifier>
 * <simple-identifier>    ::= (<identifier-character>)+
 * <identifier-character> ::= '_' | '+' | '-' | '$' | ASCII letter or digit
 * <escaped-identifier>   ::= '`' (<escaped-character>)+ '`', must contain at least one non-<identifier-character>
 * <escaped-characters>   ::= any UTF-8, escape backticks with double backtick.
 * <local-id>             ::= <simple-identifier>
 * ```
 * The list of descriptors for a symbol should together form a fully
 * qualified name for the symbol. That is, it should serve as a unique
 * identifier across the package. Typically, it will include one descriptor
 * for every node in the AST (along the ancestry path) between the root of
 * the file and the node corresponding to the symbol.
 * Local symbols MUST only be used for entities which are local to a Document,
 * and cannot be accessed from outside the Document.
 */
struct  Scip__Symbol
{
  ProtobufCMessage base;
  char *scheme;
  Scip__Package *package;
  size_t n_descriptors;
  Scip__Descriptor **descriptors;
};
#define SCIP__SYMBOL__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&scip__symbol__descriptor) \
    , (char *)protobuf_c_empty_string, NULL, 0,NULL }


/*
 * Unit of packaging and distribution.
 * NOTE: This corresponds to a module in Go and JVM languages.
 */
struct  Scip__Package
{
  ProtobufCMessage base;
  char *manager;
  char *name;
  char *version;
};
#define SCIP__PACKAGE__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&scip__package__descriptor) \
    , (char *)protobuf_c_empty_string, (char *)protobuf_c_empty_string, (char *)protobuf_c_empty_string }


struct  Scip__Descriptor
{
  ProtobufCMessage base;
  char *name;
  char *disambiguator;
  /*
   * NOTE: If you add new fields here, make sure to update the prepareSlot()
   * function responsible for parsing symbols.
   */
  Scip__Descriptor__Suffix suffix;
};
#define SCIP__DESCRIPTOR__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&scip__descriptor__descriptor) \
    , (char *)protobuf_c_empty_string, (char *)protobuf_c_empty_string, SCIP__DESCRIPTOR__SUFFIX__UnspecifiedSuffix }


/*
 * SymbolInformation defines metadata about a symbol, such as the symbol's
 * docstring or what package it's defined it.
 */
struct  Scip__SymbolInformation
{
  ProtobufCMessage base;
  /*
   * Identifier of this symbol, which can be referenced from `Occurence.symbol`.
   * The string must be formatted according to the grammar in `Symbol`.
   */
  char *symbol;
  /*
   * (optional, but strongly recommended) The markdown-formatted documentation
   * for this symbol. Use `SymbolInformation.signature_documentation` to
   * document the method/class/type signature of this symbol.
   * Due to historical reasons, indexers may include signature documentation in
   * this field by rendering markdown code blocks. New indexers should only
   * include non-code documentation in this field, for example docstrings.
   */
  size_t n_documentation;
  char **documentation;
  /*
   * (optional) Relationships to other symbols (e.g., implements, type definition).
   */
  size_t n_relationships;
  Scip__Relationship **relationships;
  /*
   * The kind of this symbol. Use this field instead of
   * `SymbolDescriptor.Suffix` to determine whether something is, for example, a
   * class or a method.
   */
  Scip__SymbolInformation__Kind kind;
  /*
   * (optional) The name of this symbol as it should be displayed to the user.
   * For example, the symbol "com/example/MyClass#myMethod(+1)." should have the
   * display name "myMethod". The `symbol` field is not a reliable source of
   * the display name for several reasons:
   * - Local symbols don't encode the name.
   * - Some languages have case-insensitive names, so the symbol is all-lowercase.
   * - The symbol may encode names with special characters that should not be
   *   displayed to the user.
   */
  char *display_name;
  /*
   * (optional) The signature of this symbol as it's displayed in API
   * documentation or in hover tooltips. For example, a Java method that adds
   * two numbers this would have `Document.language = "java"` and `Document.text
   * = "void add(int a, int b)". The `language` and `text` fields are required
   * while other fields such as `Documentation.occurrences` can be optionally
   * included to support hyperlinking referenced symbols in the signature.
   */
  Scip__Document *signature_documentation;
  /*
   * (optional) The enclosing symbol if this is a local symbol.  For non-local
   * symbols, the enclosing symbol should be parsed from the `symbol` field
   * using the `Descriptor` grammar.
   * The primary use-case for this field is to allow local symbol to be displayed
   * in a symbol hierarchy for API documentation. It's OK to leave this field
   * empty for local variables since local variables usually don't belong in API
   * documentation. However, in the situation that you wish to include a local
   * symbol in the hierarchy, then you can use `enclosing_symbol` to locate the
   * "parent" or "owner" of this local symbol. For example, a Java indexer may
   * choose to use local symbols for private class fields while providing an
   * `enclosing_symbol` to reference the enclosing class to allow the field to
   * be part of the class documentation hierarchy. From the perspective of an
   * author of an indexer, the decision to use a local symbol or global symbol
   * should exclusively be determined whether the local symbol is accessible
   * outside the document, not by the capability to find the enclosing
   * symbol.
   */
  char *enclosing_symbol;
};
#define SCIP__SYMBOL_INFORMATION__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&scip__symbol_information__descriptor) \
    , (char *)protobuf_c_empty_string, 0,NULL, 0,NULL, SCIP__SYMBOL_INFORMATION__KIND__UnspecifiedKind, (char *)protobuf_c_empty_string, NULL, (char *)protobuf_c_empty_string }


struct  Scip__Relationship
{
  ProtobufCMessage base;
  char *symbol;
  /*
   * When resolving "Find references", this field documents what other symbols
   * should be included together with this symbol. For example, consider the
   * following TypeScript code that defines two symbols `Animal#sound()` and
   * `Dog#sound()`:
   * ```ts
   * interface Animal {
   *           ^^^^^^ definition Animal#
   *   sound(): string
   *   ^^^^^ definition Animal#sound()
   * }
   * class Dog implements Animal {
   *       ^^^ definition Dog#, relationships = [{symbol: "Animal#", is_implementation: true}]
   *   public sound(): string { return "woof" }
   *          ^^^^^ definition Dog#sound(), references_symbols = Animal#sound(), relationships = [{symbol: "Animal#sound()", is_implementation:true, is_reference: true}]
   * }
   * const animal: Animal = new Dog()
   *               ^^^^^^ reference Animal#
   * console.log(animal.sound())
   *                    ^^^^^ reference Animal#sound()
   * ```
   * Doing "Find references" on the symbol `Animal#sound()` should return
   * references to the `Dog#sound()` method as well. Vice-versa, doing "Find
   * references" on the `Dog#sound()` method should include references to the
   * `Animal#sound()` method as well.
   */
  protobuf_c_boolean is_reference;
  /*
   * Similar to `is_reference` but for "Find implementations".
   * It's common for `is_implementation` and `is_reference` to both be true but
   * it's not always the case.
   * In the TypeScript example above, observe that `Dog#` has an
   * `is_implementation` relationship with `"Animal#"` but not `is_reference`.
   * This is because "Find references" on the "Animal#" symbol should not return
   * "Dog#". We only want "Dog#" to return as a result for "Find
   * implementations" on the "Animal#" symbol.
   */
  protobuf_c_boolean is_implementation;
  /*
   * Similar to `references_symbols` but for "Go to type definition".
   */
  protobuf_c_boolean is_type_definition;
  /*
   * Allows overriding the behavior of "Go to definition" and "Find references"
   * for symbols which do not have a definition of their own or could
   * potentially have multiple definitions.
   * For example, in a language with single inheritance and no field overriding,
   * inherited fields can reuse the same symbol as the ancestor which declares
   * the field. In such a situation, is_definition is not needed.
   * On the other hand, in languages with single inheritance and some form
   * of mixins, you can use is_definition to relate the symbol to the
   * matching symbol in ancestor classes, and is_reference to relate the
   * symbol to the matching symbol in mixins.
   * NOTE: At the moment, due to limitations of the SCIP to LSIF conversion,
   * only global symbols in an index are allowed to use is_definition.
   * The relationship may not get recorded if either symbol is local.
   */
  /*
   * Update registerInverseRelationships on adding a new field here.
   */
  protobuf_c_boolean is_definition;
};
#define SCIP__RELATIONSHIP__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&scip__relationship__descriptor) \
    , (char *)protobuf_c_empty_string, 0, 0, 0, 0 }


/*
 * Occurrence associates a source position with a symbol and/or highlighting
 * information.
 * If possible, indexers should try to bundle logically related information
 * across occurrences into a single occurrence to reduce payload sizes.
 */
struct  Scip__Occurrence
{
  ProtobufCMessage base;
  /*
   * Half-open [start, end) range of this occurrence. Must be exactly three or four
   * elements:
   * - Four elements: `[startLine, startCharacter, endLine, endCharacter]`
   * - Three elements: `[startLine, startCharacter, endCharacter]`. The end line
   *   is inferred to have the same value as the start line.
   * It is allowed for the range to be empty (i.e. start==end).
   * Line numbers and characters are always 0-based. Make sure to increment the
   * line/character values before displaying them in an editor-like UI because
   * editors conventionally use 1-based numbers.
   * The 'character' value is interpreted based on the PositionEncoding for
   * the Document.
   * Historical note: the original draft of this schema had a `Range` message
   * type with `start` and `end` fields of type `Position`, mirroring LSP.
   * Benchmarks revealed that this encoding was inefficient and that we could
   * reduce the total payload size of an index by 50% by using `repeated int32`
   * instead. The `repeated int32` encoding is admittedly more embarrassing to
   * work with in some programming languages but we hope the performance
   * improvements make up for it.
   */
  size_t n_range;
  int32_t *range;
  /*
   * (optional) The symbol that appears at this position. See
   * `SymbolInformation.symbol` for how to format symbols as strings.
   */
  char *symbol;
  /*
   * (optional) Bitset containing `SymbolRole`s in this occurrence.
   * See `SymbolRole`'s documentation for how to read and write this field.
   */
  int32_t symbol_roles;
  /*
   * (optional) CommonMark-formatted documentation for this specific range. If
   * empty, the `Symbol.documentation` field is used instead. One example
   * where this field might be useful is when the symbol represents a generic
   * function (with abstract type parameters such as `List<T>`) and at this
   * occurrence we know the exact values (such as `List<String>`).
   * This field can also be used for dynamically or gradually typed languages,
   * which commonly allow for type-changing assignment.
   */
  size_t n_override_documentation;
  char **override_documentation;
  /*
   * (optional) What syntax highlighting class should be used for this range?
   */
  Scip__SyntaxKind syntax_kind;
  /*
   * (optional) Diagnostics that have been reported for this specific range.
   */
  size_t n_diagnostics;
  Scip__Diagnostic **diagnostics;
  /*
   * (optional) Using the same encoding as the sibling `range` field, half-open
   * source range of the nearest non-trivial enclosing AST node. This range must
   * enclose the `range` field. Example applications that make use of the
   * enclosing_range field:
   * - Call hierarchies: to determine what symbols are references from the body
   *   of a function
   * - Symbol outline: to display breadcrumbs from the cursor position to the
   *   root of the file
   * - Expand selection: to select the nearest enclosing AST node.
   * - Highlight range: to indicate the AST expression that is associated with a
   *   hover popover
   * For definition occurrences, the enclosing range should indicate the
   * start/end bounds of the entire definition AST node, including
   * documentation.
   * ```
   * const n = 3
   *       ^ range
   * ^^^^^^^^^^^ enclosing_range
   *  ** Parses the string into something * 
   * ^ enclosing_range start --------------------------------------|
   * function parse(input string): string {                        |
   *          ^^^^^ range                                          |
   *     return input.slice(n)                                     |
   * }                                                             |
   * ^ enclosing_range end <---------------------------------------|
   * ```
   * Any attributes/decorators/attached macros should also be part of the
   * enclosing range.
   * ```python
   * @cache
   * ^ enclosing_range start---------------------|
   * def factorial(n):                           |
   *     return n * factorial(n-1) if n else 1   |
   * < enclosing_range end-----------------------|
   * ```
   * For reference occurrences, the enclosing range should indicate the start/end
   * bounds of the parent expression.
   * ```
   * const a = a.b
   *             ^ range
   *           ^^^ enclosing_range
   * const b = a.b(41).f(42).g(43)
   *                   ^ range
   *           ^^^^^^^^^^^^^ enclosing_range
   * ```
   */
  size_t n_enclosing_range;
  int32_t *enclosing_range;
};
#define SCIP__OCCURRENCE__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&scip__occurrence__descriptor) \
    , 0,NULL, (char *)protobuf_c_empty_string, 0, 0,NULL, SCIP__SYNTAX_KIND__UnspecifiedSyntaxKind, 0,NULL, 0,NULL }


/*
 * Represents a diagnostic, such as a compiler error or warning, which should be
 * reported for a document.
 */
struct  Scip__Diagnostic
{
  ProtobufCMessage base;
  /*
   * Should this diagnostic be reported as an error, warning, info, or hint?
   */
  Scip__Severity severity;
  /*
   * (optional) Code of this diagnostic, which might appear in the user interface.
   */
  char *code;
  /*
   * Message of this diagnostic.
   */
  char *message;
  /*
   * (optional) Human-readable string describing the source of this diagnostic, e.g.
   * 'typescript' or 'super lint'.
   */
  char *source;
  size_t n_tags;
  Scip__DiagnosticTag *tags;
};
#define SCIP__DIAGNOSTIC__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&scip__diagnostic__descriptor) \
    , SCIP__SEVERITY__UnspecifiedSeverity, (char *)protobuf_c_empty_string, (char *)protobuf_c_empty_string, (char *)protobuf_c_empty_string, 0,NULL }


/* Scip__Index methods */
void   scip__index__init
                     (Scip__Index         *message);
size_t scip__index__get_packed_size
                     (const Scip__Index   *message);
size_t scip__index__pack
                     (const Scip__Index   *message,
                      uint8_t             *out);
size_t scip__index__pack_to_buffer
                     (const Scip__Index   *message,
                      ProtobufCBuffer     *buffer);
Scip__Index *
       scip__index__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   scip__index__free_unpacked
                     (Scip__Index *message,
                      ProtobufCAllocator *allocator);
/* Scip__Metadata methods */
void   scip__metadata__init
                     (Scip__Metadata         *message);
size_t scip__metadata__get_packed_size
                     (const Scip__Metadata   *message);
size_t scip__metadata__pack
                     (const Scip__Metadata   *message,
                      uint8_t             *out);
size_t scip__metadata__pack_to_buffer
                     (const Scip__Metadata   *message,
                      ProtobufCBuffer     *buffer);
Scip__Metadata *
       scip__metadata__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   scip__metadata__free_unpacked
                     (Scip__Metadata *message,
                      ProtobufCAllocator *allocator);
/* Scip__ToolInfo methods */
void   scip__tool_info__init
                     (Scip__ToolInfo         *message);
size_t scip__tool_info__get_packed_size
                     (const Scip__ToolInfo   *message);
size_t scip__tool_info__pack
                     (const Scip__ToolInfo   *message,
                      uint8_t             *out);
size_t scip__tool_info__pack_to_buffer
                     (const Scip__ToolInfo   *message,
                      ProtobufCBuffer     *buffer);
Scip__ToolInfo *
       scip__tool_info__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   scip__tool_info__free_unpacked
                     (Scip__ToolInfo *message,
                      ProtobufCAllocator *allocator);
/* Scip__Document methods */
void   scip__document__init
                     (Scip__Document         *message);
size_t scip__document__get_packed_size
                     (const Scip__Document   *message);
size_t scip__document__pack
                     (const Scip__Document   *message,
                      uint8_t             *out);
size_t scip__document__pack_to_buffer
                     (const Scip__Document   *message,
                      ProtobufCBuffer     *buffer);
Scip__Document *
       scip__document__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   scip__document__free_unpacked
                     (Scip__Document *message,
                      ProtobufCAllocator *allocator);
/* Scip__Symbol methods */
void   scip__symbol__init
                     (Scip__Symbol         *message);
size_t scip__symbol__get_packed_size
                     (const Scip__Symbol   *message);
size_t scip__symbol__pack
                     (const Scip__Symbol   *message,
                      uint8_t             *out);
size_t scip__symbol__pack_to_buffer
                     (const Scip__Symbol   *message,
                      ProtobufCBuffer     *buffer);
Scip__Symbol *
       scip__symbol__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   scip__symbol__free_unpacked
                     (Scip__Symbol *message,
                      ProtobufCAllocator *allocator);
/* Scip__Package methods */
void   scip__package__init
                     (Scip__Package         *message);
size_t scip__package__get_packed_size
                     (const Scip__Package   *message);
size_t scip__package__pack
                     (const Scip__Package   *message,
                      uint8_t             *out);
size_t scip__package__pack_to_buffer
                     (const Scip__Package   *message,
                      ProtobufCBuffer     *buffer);
Scip__Package *
       scip__package__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   scip__package__free_unpacked
                     (Scip__Package *message,
                      ProtobufCAllocator *allocator);
/* Scip__Descriptor methods */
void   scip__descriptor__init
                     (Scip__Descriptor         *message);
size_t scip__descriptor__get_packed_size
                     (const Scip__Descriptor   *message);
size_t scip__descriptor__pack
                     (const Scip__Descriptor   *message,
                      uint8_t             *out);
size_t scip__descriptor__pack_to_buffer
                     (const Scip__Descriptor   *message,
                      ProtobufCBuffer     *buffer);
Scip__Descriptor *
       scip__descriptor__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   scip__descriptor__free_unpacked
                     (Scip__Descriptor *message,
                      ProtobufCAllocator *allocator);
/* Scip__SymbolInformation methods */
void   scip__symbol_information__init
                     (Scip__SymbolInformation         *message);
size_t scip__symbol_information__get_packed_size
                     (const Scip__SymbolInformation   *message);
size_t scip__symbol_information__pack
                     (const Scip__SymbolInformation   *message,
                      uint8_t             *out);
size_t scip__symbol_information__pack_to_buffer
                     (const Scip__SymbolInformation   *message,
                      ProtobufCBuffer     *buffer);
Scip__SymbolInformation *
       scip__symbol_information__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   scip__symbol_information__free_unpacked
                     (Scip__SymbolInformation *message,
                      ProtobufCAllocator *allocator);
/* Scip__Relationship methods */
void   scip__relationship__init
                     (Scip__Relationship         *message);
size_t scip__relationship__get_packed_size
                     (const Scip__Relationship   *message);
size_t scip__relationship__pack
                     (const Scip__Relationship   *message,
                      uint8_t             *out);
size_t scip__relationship__pack_to_buffer
                     (const Scip__Relationship   *message,
                      ProtobufCBuffer     *buffer);
Scip__Relationship *
       scip__relationship__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   scip__relationship__free_unpacked
                     (Scip__Relationship *message,
                      ProtobufCAllocator *allocator);
/* Scip__Occurrence methods */
void   scip__occurrence__init
                     (Scip__Occurrence         *message);
size_t scip__occurrence__get_packed_size
                     (const Scip__Occurrence   *message);
size_t scip__occurrence__pack
                     (const Scip__Occurrence   *message,
                      uint8_t             *out);
size_t scip__occurrence__pack_to_buffer
                     (const Scip__Occurrence   *message,
                      ProtobufCBuffer     *buffer);
Scip__Occurrence *
       scip__occurrence__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   scip__occurrence__free_unpacked
                     (Scip__Occurrence *message,
                      ProtobufCAllocator *allocator);
/* Scip__Diagnostic methods */
void   scip__diagnostic__init
                     (Scip__Diagnostic         *message);
size_t scip__diagnostic__get_packed_size
                     (const Scip__Diagnostic   *message);
size_t scip__diagnostic__pack
                     (const Scip__Diagnostic   *message,
                      uint8_t             *out);
size_t scip__diagnostic__pack_to_buffer
                     (const Scip__Diagnostic   *message,
                      ProtobufCBuffer     *buffer);
Scip__Diagnostic *
       scip__diagnostic__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   scip__diagnostic__free_unpacked
                     (Scip__Diagnostic *message,
                      ProtobufCAllocator *allocator);
/* --- per-message closures --- */

typedef void (*Scip__Index_Closure)
                 (const Scip__Index *message,
                  void *closure_data);
typedef void (*Scip__Metadata_Closure)
                 (const Scip__Metadata *message,
                  void *closure_data);
typedef void (*Scip__ToolInfo_Closure)
                 (const Scip__ToolInfo *message,
                  void *closure_data);
typedef void (*Scip__Document_Closure)
                 (const Scip__Document *message,
                  void *closure_data);
typedef void (*Scip__Symbol_Closure)
                 (const Scip__Symbol *message,
                  void *closure_data);
typedef void (*Scip__Package_Closure)
                 (const Scip__Package *message,
                  void *closure_data);
typedef void (*Scip__Descriptor_Closure)
                 (const Scip__Descriptor *message,
                  void *closure_data);
typedef void (*Scip__SymbolInformation_Closure)
                 (const Scip__SymbolInformation *message,
                  void *closure_data);
typedef void (*Scip__Relationship_Closure)
                 (const Scip__Relationship *message,
                  void *closure_data);
typedef void (*Scip__Occurrence_Closure)
                 (const Scip__Occurrence *message,
                  void *closure_data);
typedef void (*Scip__Diagnostic_Closure)
                 (const Scip__Diagnostic *message,
                  void *closure_data);

/* --- services --- */


/* --- descriptors --- */

extern const ProtobufCEnumDescriptor    scip__protocol_version__descriptor;
extern const ProtobufCEnumDescriptor    scip__text_encoding__descriptor;
extern const ProtobufCEnumDescriptor    scip__position_encoding__descriptor;
extern const ProtobufCEnumDescriptor    scip__symbol_role__descriptor;
extern const ProtobufCEnumDescriptor    scip__syntax_kind__descriptor;
extern const ProtobufCEnumDescriptor    scip__severity__descriptor;
extern const ProtobufCEnumDescriptor    scip__diagnostic_tag__descriptor;
extern const ProtobufCEnumDescriptor    scip__language__descriptor;
extern const ProtobufCMessageDescriptor scip__index__descriptor;
extern const ProtobufCMessageDescriptor scip__metadata__descriptor;
extern const ProtobufCMessageDescriptor scip__tool_info__descriptor;
extern const ProtobufCMessageDescriptor scip__document__descriptor;
extern const ProtobufCMessageDescriptor scip__symbol__descriptor;
extern const ProtobufCMessageDescriptor scip__package__descriptor;
extern const ProtobufCMessageDescriptor scip__descriptor__descriptor;
extern const ProtobufCEnumDescriptor    scip__descriptor__suffix__descriptor;
extern const ProtobufCMessageDescriptor scip__symbol_information__descriptor;
extern const ProtobufCEnumDescriptor    scip__symbol_information__kind__descriptor;
extern const ProtobufCMessageDescriptor scip__relationship__descriptor;
extern const ProtobufCMessageDescriptor scip__occurrence__descriptor;
extern const ProtobufCMessageDescriptor scip__diagnostic__descriptor;

PROTOBUF_C__END_DECLS


#endif  /* PROTOBUF_C_scip_2eproto__INCLUDED */
